(1+2+3*(abs)(-1)+13)
if(x<y,{a|a+1})(12) ~ if(x<y,$0)(12)


(1+2+3*(abs)(-1)+13)

1 + 2 + 3 *
	(
	 abs
	)
	(
	 -1
	)
+ 13

Операция присваивания 
make it in number() 
asdf:=12
(asdf:=12)+2
ans: 14
Операция извлечения
"12334"::12
array("ds",1,2,3)
ds::12:=13

`;` continue operator
x+13 ; self::0 +12
x+13;self(0)+12
{|x+12;x*3}


comma operator (push in array): 
`x,y`
if x is array
	x push y
else 
	[] push x, 
	[x] push y

`x,y,z`
[x,y] push z

a=x -> x

----------------------
добавить константы true, false
------------------------------
Добавить композицию функций (Haskell `.`)
f1#f2(3) ~ f1(f2(3))
----------------------------------
неизменяемое начение
let d=a in f(d); ~> {d|f}(a)
---------------------------------------
definition of new function from lamda, function def()
def("func1",{x|x*x})
def(:func1,{x|x*x})(3)
---------------------------------------
@abc -> "abc"
`\@([\w\d\_\$]+)` -> "%1"

or `aaa -> "aaa"
------------------------------------------------
function fibonacci ($n) {   
  if ($n == 1 || $n == 2) {     
    return 1;   
  } else {     
    return fibonacci( $n - 1)+fibonacci( $n - 2 );   
  } 
}
add reference on self:
	{n|if(n==1 || n==2, 1, call(n-1) + call(n-2))}
	max(10,call(2,20))
	{n|n==1 || n==2 ? call(n-1) + call(n-2)}
------------------
Факториал:
var fact=function(n){ return n * (n > 1 ? fact(n-1) : 1); }

{n|n * (n > 1 ? call(n-1) : 1)}
---------------------------------------
Тернарный оператор:
aaa ? bbb : ccc

`~
!@
	
`aaa
~aaa
;aaa
$aaa


-----------------------------------------------------------------------
1) Для реализации рекурсии необходимо условие выхода из цикла!
Функция if() предварительно вычисляет значения всех аргументов внутрь функции и получить результат, что ломает рекурсивный алгоритм
Для рекурсивного алгоритма, значение алгоритма вычисляется постоянно




2) 
Добавить skip метод чтобы пропустить неиспользуемый фрагмент (не вычисляя его)
	- ищем "," кол-во открытых скобок == 0
	- считаем кол-во парно открывающихся () ,{} - д. б. == 0

план на v 4x	
1) `;` continue operator
2) композицию функций `#`
3) поддержка записи массивов в виде `[1,2,3]`
4) синтаксический сахар для скобок `$`
5) в интерпретатор добавить поддержку функции `writeLn('%s %s0 %s12', 'aaa','bbb', 12)`

length(array(1,2,3))
length $ array $ 1, 2, 3
summ # map $ array(1,2,3), {x | x^2}
summ # map $ [1, 2, 3], {x | x^2}

Для реализации композиции функций неообходимо ввести внк\утренний объект для представления вычисляемого элемента языка
f1 # f2(3) ~ f1(f2(3))
(f1 # f2)(3)
({x|...}#{x|...})(3)

Executable(){...}
	{String} alias  (for lamda)
	{Executable} composit - ссылка на объект функции, которой значение данной функции поступит в виде аргумента (или на оборот)
	{Function} execute

